import random
import os
import logging
import asyncio
from pyrogram import enums
from pyrogram.enums import ChatMembersFilter, ChatMemberStatus, ChatType
from pyrogram.types import ChatPermissions
from flask import Flask
from threading import Thread
from pymongo import MongoClient, errors
from pyrogram import Client, filters, idle
from pyrogram.errors import FloodWait, UserNotParticipant, RPCError
from pyrogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton,CallbackQuery
from time import time
import sys

# Logging setup
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logging.getLogger("pyrogram").setLevel(logging.WARNING)

# Flask app
app_web = Flask(__name__)

@app_web.route('/')
def home():
    return "Shivi Bot is Running!"

def run_flask():
    app_web.run(host="0.0.0.0", port=8080)

# Config vars
API_ID = int(os.getenv("API_ID","14050586"))
API_HASH = os.getenv("API_HASH","42a60d9c657b106370c79bb0a8ac560c")
BOT_TOKEN = os.getenv("BOT_TOKEN")
BOT_USERNAME = os.getenv("BOT_USERNAME","rishu_musicbot")
MONGO_URI = os.getenv("MONGO_URI","mongodb+srv://Krishna:pss968048@cluster0.4rfuzro.mongodb.net/?retryWrites=true&w=majority")
OWNER_ID = int(os.getenv("OWNER_ID","5738579437"))
FORCE_JOIN1 = os.getenv("FORCE_JOIN1","RishuApi")
FORCE_JOIN2 = os.getenv("FORCE_JOIN2","rishucoder")

# MongoDB setup
try:
    client = MongoClient(MONGO_URI)
    db = client["banall_bot"]
    users_col = db["users"]
except errors.ConnectionFailure as e:
    logging.error(f"Failed to connect to MongoDB: {e}")
    sys.exit(1)

# Pyrogram bot
bot = Client(
    "banall",
    api_id=API_ID,
    api_hash=API_HASH,
    bot_token=BOT_TOKEN,
)
app = Client("my_bot", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN)

async def check_force_join(user_id):
    """Check if the user is a member of both required channels."""
    try:
        await bot.get_chat_member(FORCE_JOIN1, user_id)
        await bot.get_chat_member(FORCE_JOIN2, user_id)
        return True
    except UserNotParticipant:
        return False
    except RPCError as e:
        logging.warning(f"Error checking force join for {user_id}: {e}")
        return False


STICKERS = [
    "CAACAgUAAxkBAAENygtnrrVXr5zEE-h_eiG8lRUkRkMwfwACExMAAjRk6VbUUzZjByHDfzYE",  # Sticker 1
    "CAACAgUAAxkBAAENyglnrrUIPfP95UfP7Tg2GAz8b_mbBAACHAsAAgFTKFR6GWIrt0FPfTYE",  # Sticker 2
    "CAACAgUAAxkBAAENygdnrrSuukBGTLd_k2q-kPf80pPMqgAClw0AAmdr-Fcu4b8ZzcizqDYE",  # Sticker 3
    "CAACAgUAAxkBAAENygtnrrVXr5zEE-h_eiG8lRUkRkMwfwACExMAAjRk6VbUUzZjByHDfzYE",  # Sticker 4
    "CAACAgUAAxkBAAENyglnrrUIPfP95UfP7Tg2GAz8b_mbBAACHAsAAgFTKFR6GWIrt0FPfTYE"   # Sticker 5
]

@bot.on_message(filters.command("start") & filters.private)
async def start_command(client, message: Message):
    user = message.from_user
    user_id = user.id
    username = f"@{user.username}" if user.username else "No Username"

    # Force join check
    if not await check_force_join(user_id):
        return await message.reply_text(
            "**‚ùå You must join our channels first!**",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üç¨Join üç¨", url=f"https://t.me/{FORCE_JOIN1}")],
                [InlineKeyboardButton("üç¨ Join üç¨", url=f"https://t.me/{FORCE_JOIN2}")],
                [InlineKeyboardButton("‚úÖ I Joined", callback_data="check_force")]
            ])
        )

    # Start progress animation
    baby = await message.reply_text("[‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°] 0%")
    progress = [
        "[‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°] 10%", "[‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°] 20%", "[‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°] 30%",
        "[‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°] 40%", "[‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°‚ñ°] 50%", "[‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°‚ñ°] 60%",
        "[‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°‚ñ°] 70%", "[‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°‚ñ°] 80%", "[‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ°] 90%",
        "[‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†‚ñ†] 100%"
    ]
    for step in progress:
        await baby.edit_text(f"**{step}**")
        await asyncio.sleep(0.2)

    await baby.edit_text("**‚ùñ J·¥Ä è S ú Ä·¥á·¥á R·¥Ä·¥ç üö©...**")
    await asyncio.sleep(2)

    # ‚úÖ **Send a random sticker from the list with error handling**
    try:
        random_sticker = random.choice(STICKERS)  # Ensure STICKERS is a valid list
        await message.reply_sticker(random_sticker)
    except Exception as e:
        print(f"Sticker send failed: {e}")  # Debugging: Check if sticker is invalid

    await asyncio.sleep(1)

    # ‚úÖ **Ensure progress message is deleted even if sticker fails**
    try:
        await baby.delete()
    except Exception as e:
        print(f"Failed to delete progress message: {e}")

    # ‚úÖ **MongoDB Check & Insert New User Only Once**
    try:
        existing_user = users_col.find_one({"_id": user_id})  # Check if user exists

        if not existing_user:
            users_col.insert_one({"_id": user_id, "username": user.username})
            total_users = users_col.count_documents({})  # Count total users

            # ‚úÖ **Send notification to owner only for new users**
            await bot.send_message(
                OWNER_ID, 
                f"**New User Alert!**\nüë§ **User:** {user.mention}\n"
                f"üÜî **ID:** `{user_id}`\nüìõ **Username:** {username}\n"
                f"üìä **Total Users:** `{total_users}`"
            )

    except Exception as e:
        print(f"MongoDB Error: {e}")

    # Main Start Message
    await message.reply_photo(
        photo="https://files.catbox.moe/qej5mx.jpg",
        caption=f"""**‚ú¶ ¬ª  ú·¥á è {user.mention}**
**‚ú¶ ¬ª ·¥õ ú…™s …™s ·¥Ä s…™·¥ç·¥ò ü·¥á  ô·¥Ä…¥ ·¥Ä ü ü  ô·¥è·¥õ ·¥° ú…™·¥Ñ ú …™s  ô·¥Äs·¥á·¥Ö ·¥è…¥ ·¥ò è Ä·¥è…¢ Ä·¥Ä·¥ç  ü…™ ô Ä·¥Ä Ä è.**

**‚ú¶ ¬ª  ô·¥Ä…¥ ·¥è Ä ·¥Ö·¥ás·¥õ Ä·¥è è ·¥Ä ü ü ·¥õ ú·¥á ·¥ç·¥á·¥ç ô·¥á Äs “ì Ä·¥è·¥ç ·¥Ä …¢ Ä·¥è·¥ú·¥ò ·¥°…™·¥õ ú…™…¥ ·¥Ä “ì·¥á·¥° s·¥á·¥Ñ·¥è…¥·¥Ös.**

**‚ú¶ ¬ª ·¥Ñ ú·¥á·¥Ñ·¥ã ·¥ç è ·¥Ä ô…™ ü…™·¥õ è, …¢…™·¥†·¥á ·¥ç·¥á “ì·¥ú ü ü ·¥ò·¥è·¥°·¥á Äs ·¥Ä…¥·¥Ö ·¥õ è·¥ò·¥á `/banall` ·¥õ·¥è Íú±·¥á·¥á ·¥ç·¥Ä…¢…™·¥Ñ …™…¥ …¢ Ä·¥è·¥ú·¥ò.**""",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚úô  å·¥Ö·¥Ö œª—î …™Œ∑  èœÉœÖ Ä …¢ ÄœÉœÖ·¥ò ‚úô", url=f"https://t.me/{BOT_USERNAME}?startgroup=true")],
            [InlineKeyboardButton("Àπ sœÖ·¥ò·¥òœÉ Ä·¥õ Àº", url="http://t.me/rishu1286"),
             InlineKeyboardButton("Àπ œÖ·¥ò·¥Ö·¥ß·¥õ—îs Àº", url="http://t.me/ur_rishu_143")],
            [InlineKeyboardButton("Àπ  ú—î ü·¥ò ·¥ßŒ∑·¥Ö ·¥ÑœÉœªœª·¥ßŒ∑·¥Ö | ·¥çœÉ Ä—î …™Œ∑“ìœÉ Àº", callback_data="help_main")]
        ])
    )

@bot.on_callback_query()
async def callback_handler(client, query: CallbackQuery):
    await query.answer()  # Callback properly acknowledge karega

    # ‚úÖ Force Join Check
    if query.data == "check_force":
        user_id = query.from_user.id
        if await check_force_join(user_id):
            await query.message.edit_text("‚úÖ **You have joined! Now you can use the bot.**")
        else:
            await query.answer("‚ùå You haven't joined both channels yet!", show_alert=True)
        return

    # ‚úÖ Help Menu Handling
    elif query.data == "help_main":
        await query.message.edit_text(
            "**üîπ Help Menu üîπ**\n\nChoose a category below to get more details:",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Àπ  ô·¥ßs…™·¥Ñ Àº", callback_data="help_basic"),
                 InlineKeyboardButton("Àπ ·¥ß·¥Öœª…™Œ∑ Àº", callback_data="help_admin")],
                [InlineKeyboardButton("Àπ ·¥ß·¥Ö·¥†·¥ßŒ∑·¥Ñ—î Àº", callback_data="help_advanced")],
                [InlineKeyboardButton("‚åØ  ô·¥ß·¥Ñ·¥ã ‚åØ", callback_data="back_to_start")]
            ])
        )

    elif query.data == "help_basic":
        await query.message.edit_text(
            "**üõ† Basic Commands:**\n"
            "`/start` - Start the bot\n"
            "`/help` - Show this help menu\n"
            "`/info` - Get your user info\n"
            "`/about` - Know about the bot",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚åØ  ô·¥ß·¥Ñ·¥ã ‚åØ", callback_data="help_main")]
            ])
        )

    elif query.data == "help_admin":
        await query.message.edit_text(
            "**üîí Admin Commands:**\n"
            "`/ban` - Ban a user\n"
            "`/unban` - Unban a user\n"
            "`/mute` - Mute a user\n"
            "`/unmute` - Unmute a user\n"
            "`/unpin` - Unpin a message",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚åØ  ô·¥ß·¥Ñ·¥ã ‚åØ", callback_data="help_main")]
            ])
        )

    elif query.data == "help_advanced":
        await query.message.edit_text(
            "**‚öôÔ∏è Advanced Features:**\n"
            "`/banall` - Ban all members in a group\n"
            "`/unbanall` - Unban all members\n"
            "`/muteall` - Mute all members\n"
            "`/unmuteall` - Unmute all members\n"
            "`/broadcast` - Send a message to all users",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚åØ  ô·¥ß·¥Ñ·¥ã ‚åØ", callback_data="help_main")]
            ])
        )

    elif query.data == "back_to_start":
        user = query.from_user
        await query.message.edit_text(
            f"""**‚ú¶ ¬ª  ú·¥á è {user.mention}**
**‚ú¶ ¬ª ·¥õ ú…™s …™s ·¥Ä s…™·¥ç·¥ò ü·¥á  ô·¥Ä…¥ ·¥Ä ü ü  ô·¥è·¥õ ·¥° ú…™·¥Ñ ú …™s  ô·¥Äs·¥á·¥Ö ·¥è…¥ ·¥ò è Ä·¥è…¢ Ä·¥Ä·¥ç  ü…™ ô Ä·¥Ä Ä è.**

**‚ú¶ ¬ª  ô·¥Ä…¥ ·¥è Ä ·¥Ö·¥ás·¥õ Ä·¥è è ·¥Ä ü ü ·¥õ ú·¥á ·¥ç·¥á·¥ç ô·¥á Äs “ì Ä·¥è·¥ç ·¥Ä …¢ Ä·¥è·¥ú·¥ò ·¥°…™·¥õ ú…™…¥ ·¥Ä “ì·¥á·¥° s·¥á·¥Ñ·¥è…¥·¥Ös.**

**‚ú¶ ¬ª ·¥Ñ ú·¥á·¥Ñ·¥ã ·¥ç è ·¥Ä ô…™ ü…™·¥õ è, …¢…™·¥†·¥á ·¥ç·¥á “ì·¥ú ü ü ·¥ò·¥è·¥°·¥á Äs ·¥Ä…¥·¥Ö ·¥õ è·¥ò·¥á `/banall` ·¥õ·¥è Íú±·¥á·¥á ·¥ç·¥Ä…¢…™·¥Ñ …™…¥ …¢ Ä·¥è·¥ú·¥ò.**""",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚úô  å·¥Ö·¥Ö œª—î …™Œ∑  èœÉœÖ Ä …¢ ÄœÉœÖ·¥ò ‚úô", url=f"https://t.me/{BOT_USERNAME}?startgroup=true")],
                [InlineKeyboardButton("Àπ sœÖ·¥ò·¥òœÉ Ä·¥õ Àº", url="http://t.me/rishu1286"),
                 InlineKeyboardButton("Àπ œÖ·¥ò·¥Ö·¥ß·¥õ—îs Àº", url="http://t.me/ur_rishu_143")],
                [InlineKeyboardButton("Àπ  ú—î ü·¥ò ·¥ßŒ∑·¥Ö ·¥ÑœÉœªœª·¥ßŒ∑·¥Ö | ·¥çœÉ Ä—î …™Œ∑“ìœÉ Àº", callback_data="help_main")]
            ])
        )

@bot.on_message(filters.command("banall") & filters.group)
async def banall_command(client, message: Message):
    chat_id = message.chat.id
    admin = await bot.get_chat_member(chat_id, message.from_user.id)

    if admin.status not in ["administrator", "creator"]:
        return await message.reply_text("‚ùå **You need to be an admin to use this command!**")

    if not admin.can_restrict_members:
        return await message.reply_text("‚ùå **I need Ban Members permission to perform this action!**")

    await message.reply_text("üîñ **Starting Backloli Process...**")
    
    count = 0
    failed = 0
    async for member in bot.get_chat_members(chat_id):
        try:
            if member.user.id != message.from_user.id and member.user.id != bot.me.id:
                await bot.ban_chat_member(chat_id, member.user.id)
                count += 1
        except Exception as e:
            failed += 1

    await message.reply_text(f"‚úÖ **Banned {count} members!**\n‚ùå **Failed: {failed}**")

@bot.on_message(filters.command("kickall") & filters.group)
async def kickall_command(client, message: Message):
    chat_id = message.chat.id
    bot_member = await client.get_chat_member(chat_id, client.me.id)

    # ‚úÖ Bot ke paas kick permissions hai ya nahi
    if not bot_member.privileges or not bot_member.privileges.can_restrict_members:
        return await message.reply_text("‚ùå **I don't have permission to kick members!**")

    kicked_count = 0
    failed_count = 0

    async for member in client.get_chat_members(chat_id):
        # ‚ùå Skip: Bots & Admins ko kick nahi karega
        if member.user.is_bot or member.status in ["administrator", "creator"]:
            continue  

        try:
            await client.ban_chat_member(chat_id, member.user.id)
            await client.unban_chat_member(chat_id)
            kicked_count += 1
        except Exception as e:
            failed_count += 1
            logging.error(f"Failed to kick {member.user.id}: {e}")

    # ‚úÖ Final Summary Message
    await message.reply_text(f"‚úÖ **Successfully kicked {kicked_count} members!**\n‚ùå **Failed: {failed_count}**")

@bot.on_message(filters.command("muteall") & filters.group)
async def muteall_command(client, message):
    chat_id = message.chat.id
    bot_member = await client.get_chat_member(chat_id, client.me.id)

    # ‚úÖ Bot ke paas mute permissions hai ya nahi
    if not bot_member.privileges or not bot_member.privileges.can_restrict_members:
        return await message.reply_text("‚ùå **I don't have permission to mute members!**")

    muted_count = 0
    failed_count = 0

    async for member in client.get_chat_members(chat_id):
        # ‚ùå Skip: Bots & Admins ko mute nahi karega
        if member.user.is_bot or member.status in ["administrator", "creator"]:
            continue  

        try:
            await client.restrict_chat_member(chat_id, member.user.id, ChatPermissions(can_send_messages=False))
            muted_count += 1
        except Exception as e:
            failed_count += 1
            logging.error(f"Failed to mute {member.user.id}: {e}")

    # ‚úÖ Final Summary Message
    await message.reply_text(f"‚úÖ **Successfully muted {muted_count} members!**\n‚ùå **Failed: {failed_count}**")

@bot.on_message(filters.command("unbanall") & filters.group)
async def unbanall_command(client, message):
    chat_id = message.chat.id
    bot_member = await client.get_chat_member(chat_id, client.me.id)

    # ‚úÖ Bot ke paas unban permissions hai ya nahi
    if not bot_member.privileges or not bot_member.privileges.can_restrict_members:
        return await message.reply_text("‚ùå **I don't have permission to unban members!**")

    unbanned_count = 0
    failed_count = 0

    async for member in client.get_chat_members(chat_id, filter=enums.ChatMembersFilter.BANNED):
        try:
            await client.unban_chat_member(chat_id, member.user.id)
            unbanned_count += 1
        except Exception as e:
            failed_count += 1
            logging.error(f"Failed to unban {member.user.id}: {e}")

    # ‚úÖ Final Summary Message
    await message.reply_text(f"‚úÖ **Successfully unbanned {unbanned_count} members!**\n‚ùå **Failed: {failed_count}**")

@app.on_message(filters.command("unpinall") & filters.group)
async def unpin_all(client, message):
    chat_id = message.chat.id
    bot_member = await client.get_chat_member(chat_id, client.me.id)

    # ‚úÖ Check: Bot ke paas unpin permissions hai ya nahi
    if not bot_member.privileges or not bot_member.privileges.can_pin_messages:
        return await message.reply_text("‚ùå **I don't have permission to unpin messages!**")

    try:
        await client.unpin_all_chat_messages(chat_id)
        await message.reply_text("‚úÖ **Successfully unpinned all messages in this group!**")
    except Exception as e:
        logging.error(f"Error in unpin_all: {e}")
        await message.reply_text("‚ùå **Failed to unpin messages.**")

@app.on_message(filters.command("unmuteall") & filters.group)
async def unmute_all(client, message):
    chat_id = message.chat.id
    bot_member = await client.get_chat_member(chat_id, BOT_ID)

    # ‚úÖ Check: Bot ke paas restrict permission hai ya nahi
    if not bot_member.privileges or not bot_member.privileges.can_restrict_members:
        return await message.reply_text("‚ùå **I don't have permission to unmute members!**")

    unmuted_count = 0
    failed_count = 0

    async for member in client.get_chat_members(chat_id, filter=enums.ChatMembersFilter.RESTRICTED):
        try:
            await client.restrict_chat_member(
                chat_id, 
                member.user.id, 
                ChatPermissions(
                    can_send_messages=True,
                    can_send_media_messages=True,
                    can_send_polls=True,
                    can_add_web_page_previews=True,
                    can_invite_users=True
                )
            )
            unmuted_count += 1
        except Exception as e:
            failed_count += 1
            print(f"‚ùå Failed to unmute {member.user.id}: {e}")

    # ‚úÖ Final Message (Summary)
    await message.reply_text(f"‚úÖ **Successfully unmuted {unmuted_count} members!**\n‚ùå **Failed: {failed_count}**")

@bot.on_message(filters.command("ping"))
async def ping_command(client, message: Message):
    start = time()
    reply = await message.reply_text("üèì **Pinging...**")
    end = time()
    await reply.edit_text(f"üèì **Pong!**\nüì° **Latency:** `{round((end - start) * 1000)}ms`")

@app.on_message(filters.command("broadcast") & filters.user(OWNER_ID))
async def broadcast(client, message):
    if not message.reply_to_message:
        return await message.reply_text("**Reply to a message to broadcast!**")
    
    users = db.users.find()  # MongoDB se sab users ka data le raha hai
    sent_count = 0
    failed_count = 0

    for user in users:
        try:
            await message.reply_to_message.copy(user["user_id"])
            sent_count += 1
            await asyncio.sleep(0.5)  # Spam avoid karne ke liye
        except Exception as e:
            failed_count += 1
            print(f"Failed to send message to {user['user_id']}: {e}")

    await message.reply_text(f"‚úÖ **Broadcast Sent Successfully!**\nüì© Sent: {sent_count}\n‚ùå Failed: {failed_count}")

@bot.on_message(filters.command("restart") & filters.user(OWNER_ID))
async def restart_command(client, message: Message):
    await message.reply_text("üîÑ **Restarting bot...**")
    os.execl(sys.executable, sys.executable, *sys.argv)

# Start Flask in a separate thread
Thread(target=run_flask).start()

# Start bot
try:
    bot.start()
    logging.info("Shivi Bot is Running!")
    idle()
except Exception as e:
    logging.error(f"Bot failed to start: {e}")
